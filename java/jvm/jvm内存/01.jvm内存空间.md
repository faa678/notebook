01.jvm内存空间



空间划分：  

> 1. 虚拟机栈：栈帧 Stack Frame
> 2. 程序计数器（Program Counter）：描述下一行执行的字节码
> 3. 本地方法栈：主要用于执行本地方法（native，非java实现）
> 4. 堆（Heap）：jvm管理最大的一块内存空间，与堆相关的一个重要概念是垃圾收集器。现代几乎所有的垃圾收集器都是采用的分代收集算法，所以，堆空间也基于这一点进行了相应的划分：新生代与老年代。Eden空间，From Survivor空间与To Survivor空间。 
> 5. 方法区（Method Area）：存储元信息。永久代（Permanent Generation）, 从jdk1.8开始，彻底废弃了永久代，使用元空间（meta space）
> 6. 运行时常量池：方法区的一部分内容
> 7. 直接内存（Direct Memory）：与Java NIO密切相关。jvm通过堆上的DirectByteBuffer来操作直接内存。



* 线程私有：虚拟机栈、程序计数器、本地方法栈

* 线程共享：堆、常量池、

  

new出来的<font color=red>对象</font>本身在<font color=red>堆</font>上，<font color=blue>对象引用</font>在<font color=blue>虚拟机栈</font>上

元数据：对象<font color=red>所属的类的信息</font>（方法区中 ） 



java创建对象的过程：  

​	new关键字创建对象的3个步骤：  

  1. 在堆内存中创建出对象的实例

  2. 为对象的实力成员变量赋初值

  3. 将对象的引用返回

     

指针碰撞（前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间）

空闲列表（前提是堆内存中的空间中已被使用与未被使用的空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，哪些空间是已被使用的，接下来找出可以容纳新创建对象的未被使用的空间，在此空间存放该对象，同事还要修改列表上的记录）



对象在内存中的布局： 

1. 对象头
2. 实力数据（即我们在一个类中所声明的各项信息）
3. 对齐填充（可选）

引用访问对象的方式：

1. 使用句柄的方式
2. 使用直接指针的方式



示例代码：  

```java
import java.util.ArrayList;
import java.util.List;

public class MyTest1 {

    public static void main(String[] args) {
        List<MyTest1> list = new ArrayList<>();
        for(; ;) {
            list.add(new MyTest1());
        }
    }

}
```

jvm参数设置：  

-Xms5m（堆最小空间设置为5m）

-Xmx5m（堆最大空间设置为5m）

-XX:+HeapDumpOnOutOfMemoryError（打出溢出时堆转储信息）



执行结果：

```
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid20725.hprof ...
Heap dump file created [8724332 bytes in 0.051 secs]
2 actionable tasks: 1 executed, 1 up-to-date
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOf(Arrays.java:3210)
	at java.util.Arrays.copyOf(Arrays.java:3181)
	at java.util.ArrayList.grow(ArrayList.java:265)
	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)
	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)
	at java.util.ArrayList.add(ArrayList.java:462)
	at com.faa.jvm.memory.MyTest1.main(MyTest1.java:11)
```



##### 虚拟机栈溢出

```java
public class MyTest2 {

    private int length;

    public int getLength() {
        return length;
    }

    public void test() {
        this.length++;

        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        test();
    }

    public static void main(String[] args) {
        MyTest2 myTest2 = new MyTest2();
        try {
            myTest2.test();
        } catch (Throwable ex) {
            System.out.println(myTest2.getLength());
            ex.printStackTrace();
        }
    }

}
```

jvm参数设置：  

-Xss228k（设置虚拟机栈大小228k）

```
2568
java.lang.StackOverflowError
	at com.faa.jvm.memory.MyTest2.test(MyTest2.java:24)
com.faa.jvm.memory.MyTest2.test(MyTest2.java:24)
......
```



##### 死锁

```java
package com.faa.jvm.memory;

public class MyTest3 {

    public static void main(String[] args) {
        new Thread(() -> A.method(), "Thread-A").start();
        new Thread(() -> B.method(), "Thread-B").start();

        try {
            Thread.sleep(40000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

}

class A {

    //线程进入synchronized的静态方法时，是对当前类的Class对象加锁，而不是对类的实例对象加锁
    public static synchronized void method() {
        System.out.println("method from A");

        try {
            Thread.sleep(5000);
            B.method();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}

class B {
    public static synchronized void method()  {
        System.out.println("method from B");

        try {
            Thread.sleep(5000);
            A.method();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
```



##### 方法区内存溢出

```java
//cglib通过继承一个类的方式实现动态代理
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;

public class MyTest4 {

    public static void main(String[] args) {
        for(; ;) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(MyTest4.class);
            enhancer.setUseCache(false);
            enhancer.setCallback((MethodInterceptor) (obj, method, arg1, proxy) ->
                    proxy.invokeSuper(obj, arg1));

            System.out.println("hello world");
            enhancer.create();//不断创建MyTest4的子类
        }
    }

}
```

jvm参数设置：  

-XX:MaxMetaspaceSize=10m（设置元空间最大10m）

执行结果

```
hello world
hello world
......
Exception in thread "main" java.lang.OutOfMemoryError: Metaspace
......
com.faa.jvm.memory.MyTest4.main(MyTest4.java:22)
```

解析：  

元空间大小会逐步增加，如果不设置最大值，则最大为物理内存大小。